<!DOCTYPE sqlMap
    PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN"
    "http://ibatis.apache.org/dtd/sql-map-2.dtd">

<sqlMap namespace="wlgRecoveryService">

<delete id="deleteAppendixA" parameterClass="java.util.Map">
DELETE FROM PTRACCOUNT_IL_APPENDIXA
</delete>

<delete id="deletePaidAccountsOd" parameterClass="java.util.Map">
DELETE FROM ptraccount_work_list_assignment where account_id in (select account_id from ptraccount where OD_STATUS = 2)
</delete>

<delete id="deletePaidAccountsOdIL" parameterClass="java.util.Map">
DELETE FROM ptraccount_il_work_list_assignment where account_id in (select account_id from ptraccount where OD_STATUS = 2)
</delete>


<update id="updateAppendixaWorkListAssignment" parameterClass="java.util.Map">
merge into ptraccount_work_list_assignment as asgmt using
(
   select
   -888 as tree_run_id,
   appendix.account_id, 
   appendix.work_list_id, 
   current_date as assignment_date,
   1 AS is_appendix_a,
   current_timestamp AS appendix_a_assignment_time
   from ptraccount a
   inner join ptraccount_il_appendixa appendix on a.id = appendix.account_id
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code not in ('OD','OD_IL_FLOAT','OD_IL_FIXED','OD_IL_BDR','HP_IL_FLOAT','HP_IL_FIXED') 
   and a.account_status_id &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.work_list_id = n.work_list_id,
asgmt.tree_run_id = n.tree_run_id,
asgmt.assignment_date = n.assignment_date,
asgmt.is_appendix_a = 1,
asgmt.appendix_a_assignment_time = current_timestamp,
asgmt.updated_time = current_timestamp
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date,asgmt.is_appendix_a,asgmt.appendix_a_assignment_time)
values
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date,n.is_appendix_a,n.appendix_a_assignment_time)
</update>



<update id="updateAppendixaWorkListAssignmentHpFixedFloat" parameterClass="java.util.Map">
merge into ptraccount_work_list_assignment as asgmt using
(
   select
   -888 as tree_run_id,
   appendix.account_id, 
   appendix.work_list_id, 
   current_date as assignment_date,
   1 AS is_appendix_a,
   current_timestamp AS appendix_a_assignment_time
   from ptraccount a
   inner join PTRNPL_STATUS_REF nplstatus on a.NPL_STATUS = nplstatus.ID
   inner join ptraccount_il_appendixa appendix on a.id = appendix.account_id
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code in ('HP_IL_FLOAT','HP_IL_FIXED') 
   and a.account_status_id &lt;&gt; 2
   and nplstatus.status = 'Y'
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.work_list_id = n.work_list_id,
asgmt.tree_run_id = n.tree_run_id,
asgmt.assignment_date = n.assignment_date,
asgmt.is_appendix_a = 1,
asgmt.appendix_a_assignment_time = current_timestamp,
asgmt.updated_time = current_timestamp
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date,asgmt.is_appendix_a,asgmt.appendix_a_assignment_time)
values
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date,n.is_appendix_a,n.appendix_a_assignment_time)
</update>


<update id="updateAppendixaWorkListAssignmentOd" parameterClass="java.util.Map">
merge into ptraccount_work_list_assignment as asgmt using
(
   select
   -888 as tree_run_id,
   appendix.account_id, 
   appendix.work_list_id, 
   current_date as assignment_date,
   1 AS is_appendix_a,
   current_timestamp AS appendix_a_assignment_time
   from ptraccount a
   inner join ptraccount_il_appendixa appendix on a.id = appendix.account_id
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code in ('OD','OD_IL_FLOAT','OD_IL_FIXED','OD_IL_BDR') 
   and a.OD_STATUS &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.work_list_id = n.work_list_id,
asgmt.tree_run_id = n.tree_run_id,
asgmt.assignment_date = n.assignment_date,
asgmt.is_appendix_a = 1,
asgmt.appendix_a_assignment_time = current_timestamp,
asgmt.updated_time = current_timestamp
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date,asgmt.is_appendix_a,asgmt.appendix_a_assignment_time)
values
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date,n.is_appendix_a,n.appendix_a_assignment_time)
</update>

<update id="updateAccountAppendixaWorkListAssignment" parameterClass="java.util.Map">
merge into ptraccount as asgmt using
(
   select
   -888 as tree_run_id,
   appendix.account_id, 
   appendix.work_list_id, 
   current_date as assignment_date,
   1 AS is_appendix_a,
   current_timestamp AS appendix_a_assignment_time
   from ptraccount a
   inner join ptraccount_il_appendixa appendix on a.id = appendix.account_id
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code not in ('OD','OD_IL_FLOAT','OD_IL_FIXED','OD_IL_BDR','HP_IL_FLOAT','HP_IL_FIXED') 
   and a.account_status_id &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.work_list_id = n.work_list_id
</update>

<update id="updateAccountAppendixaWorkListAssignmentHpFixedFloat" parameterClass="java.util.Map">
merge into ptraccount as asgmt using
(
   select
   -888 as tree_run_id,
   appendix.account_id, 
   appendix.work_list_id, 
   current_date as assignment_date,
   1 AS is_appendix_a,
   current_timestamp AS appendix_a_assignment_time
   from ptraccount a
   inner join PTRNPL_STATUS_REF nplstatus on a.NPL_STATUS = nplstatus.ID
   inner join ptraccount_il_appendixa appendix on a.id = appendix.account_id
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code in ('HP_IL_FLOAT','HP_IL_FIXED') 
   and a.account_status_id &lt;&gt; 2
   and nplstatus.status = 'Y'
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.work_list_id = n.work_list_id
</update>


<update id="updateAccountAppendixaWorkListAssignmentOd" parameterClass="java.util.Map">
merge into ptraccount as asgmt using
(
   select
   -888 as tree_run_id,
   appendix.account_id, 
   appendix.work_list_id, 
   current_date as assignment_date,
   1 AS is_appendix_a,
   current_timestamp AS appendix_a_assignment_time
   from ptraccount a
   inner join ptraccount_il_appendixa appendix on a.id = appendix.account_id
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code in ('OD','OD_IL_FLOAT','OD_IL_FIXED','OD_IL_BDR') 
   and a.od_status &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.work_list_id = n.work_list_id
</update>

<update id="updateAppendixaWorkListIlAssignment" parameterClass="java.util.Map">
merge into ptraccount_il_work_list_assignment as asgmt using
(
   select
   -888 as tree_run_id,
   appendix.account_id, 
   appendix.work_list_id, 
   current_date as assignment_date,
   1 AS is_appendix_a,
   current_timestamp AS appendix_a_assignment_time
   from ptraccount a
   inner join ptraccount_il_appendixa appendix on a.id = appendix.account_id
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code not in ('OD','OD_IL_FLOAT','OD_IL_FIXED','OD_IL_BDR','HP_IL_FLOAT','HP_IL_FIXED') 
   and a.account_status_id &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.work_list_id = n.work_list_id,
asgmt.tree_run_id = n.tree_run_id,
asgmt.assignment_date = n.assignment_date,
asgmt.is_appendix_a = 1,
asgmt.appendix_a_assignment_time = current_timestamp,
asgmt.updated_time = current_timestamp
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date,asgmt.is_appendix_a,asgmt.appendix_a_assignment_time)
values 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date,1,current_timestamp)
</update>



<update id="updateAppendixaWorkListIlAssignmentHpFixedFloat" parameterClass="java.util.Map">
merge into ptraccount_il_work_list_assignment as asgmt using
(
   select
   -888 as tree_run_id,
   appendix.account_id, 
   appendix.work_list_id, 
   current_date as assignment_date,
   1 AS is_appendix_a,
   current_timestamp AS appendix_a_assignment_time
   from ptraccount a
   inner join PTRNPL_STATUS_REF nplstatus on a.NPL_STATUS = nplstatus.ID
   inner join ptraccount_il_appendixa appendix on a.id = appendix.account_id
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code in ('HP_IL_FLOAT','HP_IL_FIXED') 
   and a.account_status_id &lt;&gt; 2
   and nplstatus.status = 'Y'
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.work_list_id = n.work_list_id,
asgmt.tree_run_id = n.tree_run_id,
asgmt.assignment_date = n.assignment_date,
asgmt.is_appendix_a = 1,
asgmt.appendix_a_assignment_time = current_timestamp,
asgmt.updated_time = current_timestamp
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date,asgmt.is_appendix_a,asgmt.appendix_a_assignment_time)
values 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date,1,current_timestamp)
</update>


<update id="updateAppendixaWorkListIlAssignmentOd" parameterClass="java.util.Map">
merge into ptraccount_il_work_list_assignment as asgmt using
(
   select
   -888 as tree_run_id,
   appendix.account_id, 
   appendix.work_list_id, 
   current_date as assignment_date,
   1 AS is_appendix_a,
   current_timestamp AS appendix_a_assignment_time
   from ptraccount a
   inner join ptraccount_il_appendixa appendix on a.id = appendix.account_id
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code in ('OD','OD_IL_FLOAT','OD_IL_FIXED','OD_IL_BDR') 
   and a.od_status &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.work_list_id = n.work_list_id,
asgmt.tree_run_id = n.tree_run_id,
asgmt.assignment_date = n.assignment_date,
asgmt.is_appendix_a = 1,
asgmt.appendix_a_assignment_time = current_timestamp,
asgmt.updated_time = current_timestamp
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date,asgmt.is_appendix_a,asgmt.appendix_a_assignment_time)
values 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date,1,current_timestamp)
</update>



<update id="updateAppendixaWorkListUserAssignment" parameterClass="java.util.Map">
merge into PTRUSER_WL_ASSIGN as asgmt using
(
   select
   appendix.USER_ID,
   appendix.WORK_LIST_ID
   from PTRACCOUNT_IL_APPENDIXA appendix 
   inner join PTRACCOUNT_WORK_LIST_ASSIGNMENT assign on appendix.account_id = assign.account_id
   inner join PTRACCOUNT a on appendix.account_id = a.id
   where a.ACCOUNT_STATUS_ID &lt;&gt; 2
   and appendix.user_id is not null
   and assign.WORK_LIST_ID is not null
   GROUP BY appendix.USER_ID, appendix.WORK_LIST_ID
)
n on asgmt.USER_ID = n.USER_ID AND  asgmt.WORK_LIST_ID = n.WORK_LIST_ID
when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.USER_ID = n.USER_ID,
asgmt.effective_date = cast(#CURRENT_DATE# AS DATE),
asgmt.assigner_id = 'Admin'
when not matched then
insert
(asgmt.assigner_id,asgmt.user_id,asgmt.work_list_id,asgmt.effective_date)
VALUES 
('Admin',n.user_id,n.work_list_id,current_date)
</update>



<update id="updateUnassignPaidOffAccount">
merge into PTRACCOUNT as asgmt using
(
select 
a.id as account_id
from ptraccount a
inner join ptraccount_work_list_assignment assign on a.id = assign.account_id
where assign.work_list_id is not null
and (a.account_status_id = 2 or a.od_status = 2)
)
n on (asgmt.account_id = n.account_id)
when matched then
update set 
asgmt.work_list_id = null
ELSE IGNORE
</update>


<update id="updateUnassignPaidOffAccountForWorkList">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
select 
a.id as account_id
from ptraccount a
inner join ptraccount_work_list_assignment assign on a.id = assign.account_id
where assign.work_list_id is not null
and (a.account_status_id = 2 or a.od_status = 2)
)
n on (asgmt.account_id = n.account_id)
when matched then
update set 
asgmt.work_list_id = null,
asgmt.updated_time = cast(#CURRENT_DATE# as TIMESTAMP)
ELSE IGNORE
</update>


<update id="updateUnassignPaidOffAccountForIlWorkList">
merge into PTRACCOUNT_IL_WORK_LIST_ASSIGNMENT as asgmt using
(
select 
a.id as account_id
from ptraccount a
inner join ptraccount_work_list_assignment assign on a.id = assign.account_id
where assign.work_list_id is not null
and (a.account_status_id = 2 or a.od_status = 2)
)
n on (asgmt.account_id = n.account_id)
when matched then
update set 
asgmt.work_list_id = null,
asgmt.updated_time = cast(#CURRENT_DATE# as TIMESTAMP)
ELSE IGNORE
</update>

<update id="updateAppendixABdrAccountHpForCurrentAssignment">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'HP_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.TREE_RUN_ID = n.TREE_RUN_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date)
VALUES 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date)
</update>


<update id="updateAppendixABdrAccountHp">
merge into PTRACCOUNT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'HP_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID
ELSE IGNORE
</update>


<update id="updateAppendixABdrAccountHpForIL">
merge into PTRACCOUNT_IL_WORK_LIST_ASSIGNMENT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'HP_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.TREE_RUN_ID = n.TREE_RUN_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date)
VALUES 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date)
</update>


<update id="updateAppendixABdrAccountPlForCurrentAssignment">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'UPL_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.TREE_RUN_ID = n.TREE_RUN_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date)
VALUES 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date)
</update>


<update id="updateAppendixABdrAccountPl">
merge into PTRACCOUNT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'UPL_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID
ELSE IGNORE
</update>


<update id="updateAppendixABdrAccountPlForIL">
merge into PTRACCOUNT_IL_WORK_LIST_ASSIGNMENT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'UPL_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.TREE_RUN_ID = n.TREE_RUN_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date)
VALUES 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date)
</update>







<update id="updateAppendixABdrAccountMgForCurrentAssignment">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'MG_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.TREE_RUN_ID = n.TREE_RUN_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date)
VALUES 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date)
</update>


<update id="updateAppendixABdrAccountMg">
merge into PTRACCOUNT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'MG_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID
ELSE IGNORE
</update>


<update id="updateAppendixABdrAccountMgForIL">
merge into PTRACCOUNT_IL_WORK_LIST_ASSIGNMENT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'MG_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.TREE_RUN_ID = n.TREE_RUN_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date)
VALUES 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date)
</update>






<update id="updateAppendixABdrAccountOdForCurrentAssignment">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'OD_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.TREE_RUN_ID = n.TREE_RUN_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date)
VALUES 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date)
</update>


<update id="updateAppendixABdrAccountOd">
merge into PTRACCOUNT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'OD_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID
ELSE IGNORE
</update>


<update id="updateAppendixABdrAccountOdForIL">
merge into PTRACCOUNT_IL_WORK_LIST_ASSIGNMENT as asgmt using
(
  select
   -888 as TREE_RUN_ID,
   appendix.account_id,
   appendix.WORK_LIST_ID,
   current_date as ASSIGNMENT_DATE
   from PTRACCOUNT a
   inner join PTRACCOUNT_IL_APPENDIXA appendix on a.ID = appendix.ACCOUNT_ID
   inner join PTRWORK_LIST wl on appendix.WORK_LIST_ID = wl.WORK_LIST_ID
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code = 'OD_IL_BDR'
   and a.ACCOUNT_STATUS_ID &lt;&gt; 2
)
n on asgmt.account_id = n.account_id when matched then
update set asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.TREE_RUN_ID = n.TREE_RUN_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
when not matched then
insert
(asgmt.tree_run_id,asgmt.account_id,asgmt.work_list_id,asgmt.assignment_date)
VALUES 
(n.tree_run_id,n.account_id,n.work_list_id,n.assignment_date)
</update>


<!-- 
UPDATE IL (FLOAT AND FIXED) ACCOUNTS RETURNING BACK TO WORSEOFF STATES
The cycle is IL -> Pre IL -> IL
 -->
<update id="updateILFixedHpAccounts">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
select
appendix.ACCOUNT_ID,
appendix.WORK_LIST_ID,
cast(#EFFECTIVE_DATE:DATE# as date) as assignment_date
from PTRACCOUNT_IL_WORK_LIST_ASSIGNMENT appendix
inner join ptraccount a on appendix.account_id = a.id
inner join PTRNPL_STATUS_REF nplstatus on a.NPL_STATUS = nplstatus.ID
inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
where wlgroup.code in ('HP_IL_FLOAT','HP_IL_FIXED')
and a.ACCOUNT_STATUS_ID not in (2,4,8)
and nplstatus.status = 'Y'
)
n on asgmt.account_id = n.account_id when matched then
update set 
asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
ELSE IGNORE
</update>

<!-- 
UPDATE IL (FLOAT AND FIXED) ACCOUNTS RETURNING BACK TO WORSEOFF STATES
The cycle is IL -> Pre IL -> IL
 -->
<update id="updateILFixedMgAccounts">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
select
appendix.ACCOUNT_ID,
appendix.WORK_LIST_ID,
cast(#EFFECTIVE_DATE:DATE# as date) as assignment_date
from PTRACCOUNT_IL_WORK_LIST_ASSIGNMENT appendix
inner join ptraccount a on appendix.account_id = a.id
inner join PTRNPL_STATUS_REF nplstatus on a.NPL_STATUS = nplstatus.ID
inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
where wlgroup.code in ('MG_IL_FLOAT','MG_IL_FIXED')
and a.ACCOUNT_STATUS_ID not in (2,4,8)
and nplstatus.status = 'Y'
)
n on asgmt.account_id = n.account_id when matched then
update set 
asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
ELSE IGNORE
</update>

<!-- 
UPDATE IL (FLOAT AND FIXED) ACCOUNTS RETURNING BACK TO WORSEOFF STATES
The cycle is IL -> Pre IL -> IL
 -->
<update id="updateILFixedOdAccounts">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
   select
   appendix.account_id, 
   appendix.work_list_id, 
   cast(#EFFECTIVE_DATE:DATE# as date) as assignment_date
   from PTRACCOUNT_IL_WORK_LIST_ASSIGNMENT appendix
   inner join ptraccount a  on appendix.account_id = a.id
   inner join PTRNPL_STATUS_REF nplstatus on a.NPL_STATUS = nplstatus.ID
   inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
   inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
   where wlgroup.code in ('OD_IL_FLOAT','OD_IL_FIXED')
   and a.OD_STATUS not in (2,4,8)
   and nplstatus.status = 'Y'
)
n on asgmt.account_id = n.account_id when matched then
update set 
asgmt.WORK_LIST_ID = n.WORK_LIST_ID,
asgmt.ASSIGNMENT_DATE = n.ASSIGNMENT_DATE
ELSE IGNORE
</update>


<!-- 
UPDATE IL ACCOUNTS RETURNING BACK TO BETTEROFF STATES
This will nullify the worklist of MG accounts that have moved from IL -> Pre IL
The NPL status of these MG accounts is "N" on the 1st, it is likely that the NPL status may change to "Y" on the 2nd of month, 
but then this accounts are considered belonging to Pre IL callers and not IL callers though the NPL status is "Y" on the 2nd of month
So the objective is to nullify their worklistId so that Pre IL WLG decision tree may pick it up on the 2nd of month.
 -->
 
 <update id="updateMgBecomingBetterOffAccounts">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
	select
	appendix.ACCOUNT_ID
	from PTRACCOUNT_WORK_LIST_ASSIGNMENT appendix
	inner join ptraccount a on appendix.account_id = a.id
	inner join PTRNPL_STATUS_REF nplstatus on a.NPL_STATUS = nplstatus.ID
	inner join ptrwork_list wl on appendix.work_list_id = wl.work_list_id
	inner join PTRWORK_LIST_GROUP_REF wlgroup on wl.WORK_LIST_GROUP = wlgroup.id
	where wlgroup.code  IN ('MG_IL_FLOAT','MG_IL_FIXED')
	and a.ACCOUNT_STATUS_ID not in (2,4,8)
	and nplstatus.status = 'N'
)
n on asgmt.account_id = n.account_id when matched then
update set 
asgmt.WORK_LIST_ID = null
ELSE IGNORE
</update>

<update id="updateAccountAssignmentScoringId">
merge into PTRACCOUNT_WORK_LIST_ASSIGNMENT as asgmt using
(
	select n.account_id, n.scoring_id from
	(
	
	SELECT 
	row_number()over(partition by account_id order by account_id asc) as row_num,
	account_id, 
	FIELD_VALUE as scoring_id FROM ptrconfidence_level
	
	) n where n.row_num = 1
)
n on (asgmt.account_id = n.account_id and date(asgmt.assignment_date) &gt;= cast(#EFFECTIVE_DATE:DATE# AS DATE))  when matched then
update set 
asgmt.scoring_id = n.scoring_id
ELSE IGNORE
</update>



</sqlMap>